---
title: "Practicum II - Mine a Database, CS5200 Spring 2021"
output: html_notebook
---


### Part 1 Load XML: Create a normalized relational OLTP database
```{r}
#pacman (package manager) installs and loads packages if not installed
pacman::p_load(pacman, RSQLite, XML, DBI, tidyverse)

#create db to set schema and load data to
dbs <- dbConnect(RSQLite::SQLite(), "pubMed.db")

```

### Part 1 Populate relational database with data from an XML document
### Part 2 Add to the normalized schema fact tables and turn the normalized schema into a denormalized schema suitable for OLAP


```{r}

path <- "/Users/jeannille/repos/mine_a_database/"
xmlFile <- "pubmed_sample.xml"
fpn <- paste0(path,xmlFile)

xml_data <- xmlParse(file = fpn)
nodes <- getNodeSet(xml_data, "//PubmedArticle") 
r <- xmlRoot(xml_data)

# Get the name of the node to confirm
xmlName(r)
#PubmedArticleSet

#get number of children of root, number of pubMedArticles (19)
numPubMeds <- xmlSize(r)


```


```{r}

newJournal.df <- data.frame(ISSN = character(),#cant be numeric with a hyphen?
                          journalTitle = character(),
                          ISOabbrevation = character(),
                          volume = numeric(),
                          Issue = numeric(),
                          #pubYear = numeric(),
                          #pubMonth = character(),
                          stringsAsFactors = F)

colnames(newJournal.df) <- c("ISSN","journalTitle", 
                             "ISOabbrevation","Issue","volume")#,"pubYear","pubMonth")

r <- xmlRoot(xml_data)

for (m in 1:19)
{

  aJournalNode <- r[[m]][[1]][['Article']][['Journal']] #

  aJournal <- aJournalNode[[m]]
  ISSN <- xpathSApply(aJournalNode, "./ISSN", xmlValue)
  journalTitle <- xpathSApply(aJournalNode, "./Title", xmlValue)
  ISOabbrevation <- xpathSApply(aJournalNode, "./ISOAbbreviation", xmlValue)
  volume<-xpathSApply(aJournalNode, "./JournalIssue/Volume", xmlValue)
  Issue <-xpathSApply(aJournalNode, "./JournalIssue/Issue", xmlValue)
  
  #pubYear<-xpathSApply(aJournalNode, "./JournalIssue/PubDate/Year", xmlValue)
  #pubMonth <-xpathSApply(aJournalNode, "./JournalIssue/PubDate/Month", xmlValue)
    
    
  if (length(ISSN) == 0)
    ISSN <- ""
  if (length(journalTitle) == 0)
    journalTitle <- ""
  if (length(ISOabbrevation) == 0)
    ISOabbrevation <- ""
  #if (length(pubMonth) == 0)
  #  pubMonth <- ""

  newJournal.df[m,1] <- ISSN
  newJournal.df[m,2] <- journalTitle
  newJournal.df[m,3] <- ISOabbrevation
  newJournal.df[m,4] <- volume
  newJournal.df[m,5] <- Issue
  #newJournal.df[m,6] <- pubYear
  #newJournal.df[m,7] <- pubMonth
}
  
```
```{r}
#commented out so not seen in a knitted file
#newJournal.df
```


```{r}
newArticle.df <- data.frame(PMID = numeric(), #
                          journalISSN = character(),
                          articleTitle = character(),
                          pagination = character(),
                          #elocationID can have more then 1. need another table for that?
                          #same with abstract
                          #and author list- different table? what to use as a key?
                          language = character(),
                          #grant list?
                          #publication type tist?
                          artYear = numeric(),
                          artMonth = numeric(),
                          artDay = numeric(),
                          pubYear = numeric(),
                          pubMonth = character(),
                          stringsAsFactors = F)

colnames(newArticle.df) <- c("PMID","journalISSN", 
                             "articleTitle","pagination","language", 
                             "artYear", "artMonth", "artDay", 'pubYear', "pubMonth")#

r <- xmlRoot(xml_data)

for (m in 1:19)
{
  
  anArticleNode <- r[[m]][[1]][['Article']]#[['Journal']] #

  PMID <- xpathSApply(r[[m]][[1]], "./PMID", xmlValue)
  journalISSN <- xpathSApply(anArticleNode, "./Journal/ISSN", xmlValue)
  articleTitle <- xpathSApply(anArticleNode, "./ArticleTitle", xmlValue)
  pagination <- xpathSApply(anArticleNode, "./Pagination/MedlinePgn", xmlValue)
  language <- xpathSApply(anArticleNode, "./Language", xmlValue)
  
  artYear <- xpathSApply(anArticleNode, "./ArticleDate/Year", xmlValue)
  artMonth <- xpathSApply(anArticleNode, "./ArticleDate/Month", xmlValue)
  artDay <- xpathSApply(anArticleNode, "./ArticleDate/Day", xmlValue)
  
  pubYear <- xpathSApply(anArticleNode, "./Journal/JournalIssue/PubDate/Year", xmlValue)
  pubMonth <- xpathSApply(anArticleNode, "./Journal/JournalIssue/PubDate/Month", xmlValue)
  
  
  if (length(PMID) == 0)
    PMID <- ""
  if (length(journalISSN) == 0)
    journalISSN <- ""
  if (length(articleTitle) == 0)
    articleTitle <- ""
  if (length(pagination) == 0)
    pagination <- ""
  if (length(language) == 0)
    language <- ""
  if (length(artYear) == 0)
    artYear <- ""
  if (length(artMonth) == 0)
    artMonth <- ""
  if (length(artDay) == 0)
    artDay <- ""
  
  if (length(pubYear) == 0)
    pubYear <- ""
  if (length(pubMonth) == 0)
    pubMonth <- ""

  newArticle.df[m,1] <- PMID
  newArticle.df[m,2] <- journalISSN
  newArticle.df[m,3] <- articleTitle
  newArticle.df[m,4] <- pagination
  newArticle.df[m,5] <- language
  newArticle.df[m,6] <- artYear
  newArticle.df[m,7] <- artMonth
  newArticle.df[m,8] <- artDay
  newArticle.df[m,9] <- pubYear
  newArticle.df[m,10] <- pubMonth
}

```
```{r}
#commented out so not seen in a knitted file
#newArticle.df
```

```{r}

newAuthor.df <- data.frame(PMID = numeric(),
                          lastName = character(),
                          foreName = character(),
                          initials = character(),
                          affiliation = character(),
                          stringsAsFactors = F)

colnames(newAuthor.df) <- c("PMID","lastName","foreName", 
                             "initials","affiliation")

r <- xmlRoot(xml_data)
rowCount <- 1
for (m in 1:19)
{

  PMID <- xpathSApply(r[[m]][[1]], "./PMID", xmlValue)
  if (length(PMID) == 0)
    PMID <- ""
  
  anAuthorNodeList <- r[[m]][[1]][['Article']][['AuthorList']] 
  
  j<-xmlSize(anAuthorNodeList)
  
  
  for (k in 1:j){
    
    node <-anAuthorNodeList[[k]]
    lastName <- xpathSApply(node, "./LastName", xmlValue)
    foreName <- xpathSApply(node, "./ForeName", xmlValue)
    initials <- xpathSApply(node, "./Initials", xmlValue)
    affiliation <- xpathSApply(node, "./Affiliation", xmlValue)
    
    if (length(lastName) == 0)
      lastName <- ""
    if (length(foreName) == 0)
      foreName <- ""
    if (length(initials) == 0)
      initials <- ""
    if (length(affiliation) == 0)
      affiliation <- ""
    
    newAuthor.df[rowCount,1] <- PMID
    newAuthor.df[rowCount,2] <- lastName
    newAuthor.df[rowCount,3] <- foreName
    newAuthor.df[rowCount,4] <- initials
    newAuthor.df[rowCount,5] <- affiliation
    
    
    rowCount <- rowCount+1
  }

}
  
```
```{r}
#commented out so not seen in a knitted file
#newAuthor.df
```


```{r}

newHistory.df <- data.frame(PMID = numeric(),
                          pubStatus = character(),
                          year = numeric(),
                          month = numeric(),
                          day = numeric(),
                          #hour and minute not useful for analysis?
                          stringsAsFactors = F)

colnames(newHistory.df) <- c("PMID","pubStatus","year", 
                             "month","day")

r <- xmlRoot(xml_data)
rowCount <- 1
for (m in 1:19)
{

  PMID <- xpathSApply(r[[m]][[1]], "./PMID", xmlValue)
  if (length(PMID) == 0)
    PMID <- ""
  
  aHistoryList <- r[[m]][['PubmedData']][['History']]
  
  j<-xmlSize(aHistoryList)
  
  
  for (k in 1:j){
    
    node <-aHistoryList[[k]]
    
    pubStatus <- xmlGetAttr(node,'PubStatus')

    year <- xpathSApply(node, "./Year", xmlValue)
    month <- xpathSApply(node, "./Month", xmlValue)
    day <- xpathSApply(node, "./Day", xmlValue)
    

    if (length(pubStatus) == 0)
      pubStatus <- ""
    if (length(year) == 0)
      year <- ""
    if (length(month) == 0)
      month <- ""
    if (length(day) == 0)
      day <- ""
    
    newHistory.df[rowCount,1] <- PMID
    newHistory.df[rowCount,2] <- pubStatus
    newHistory.df[rowCount,3] <- year
    newHistory.df[rowCount,4] <- month
    newHistory.df[rowCount,5] <- day
    
    
    rowCount <- rowCount+1
  }

}
  
```


```{r}
#commented out so not seen in a knitted file
newHistory.df
```



Clear tables as needed

```{sql connection=dbs}
DROP TABLE IF EXISTS Journal
```

```{sql connection=dbs}
DROP TABLE IF EXISTS Article
```

```{sql connection=dbs}
DROP TABLE IF EXISTS Authorship
```

```{sql connection=dbs}
DROP TABLE IF EXISTS Author
```

```{sql connection=dbs}
DROP TABLE IF EXISTS History

```


Create tables from ERD

```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS Journal (
  ISSN varchar(255) primary key,
  title varchar(255),
  ISOabbrevation varchar(255)

  );
```

  
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS Article (
  PMID int(255) NOT NULL,
  journalISSN varchar(255),
  title varchar(255),
  pagination varchar(255),
  language varchar(255),
  FOREIGN KEY (journalISSN ) REFERENCES Journal(ISSN)
  );
```

  histKey INTEGER primary key AUTOINCREMENT,
  
  use compound key instead?
  

```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS History (
  PMID int(255),
  pubStatus varchar(255),
  year int(255),
  month int(255),
  day int(255),
  PRIMARY  KEY (PMID, pubStatus),
  FOREIGN KEY (PMID) REFERENCES Article(PMID)
  );
```

adding in this lookup table
might need compound primary key?
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS Authorship (
  lookupKey INTEGER primary key AUTOINCREMENT,
  PMID int(255),
  lastName varchar(255),
  foreName varchar(255),
  FOREIGN KEY (PMID) REFERENCES Article(PMID),
  FOREIGN KEY (lastName, foreName) REFERENCES Author(lastName, foreName)
  );
```

  PMID int(255),
  
  ,
  FOREIGN KEY (PMID) REFERENCES Article(PMID)
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS Author (
  authorKey INTEGER primary key AUTOINCREMENT,
  lastName varchar(255),
  foreName varchar(255),
  initials varchar(255),
  affiliation varchar(255)
  );
```



Check all tables have been correctly added to database
```{r}
dbListTables(dbs)

```


Inserting data (dataframe) into tables that have been created in pubMedData database

```{r}
dbWriteTable(dbs, "journalData",newJournal.df , overwrite = TRUE)
```

```{sql connection=dbs}

SELECT DISTINCT 
ISSN,journalTitle,ISOabbrevation from journalData 
```

Insert journal data - filter by distinct journals 
```{sql connection=dbs}
INSERT INTO Journal (ISSN , title,ISOabbrevation)
SELECT  distinct ISSN, journalTitle, ISOabbrevation
FROM journalData
```


```{sql connection=dbs}

SELECT * from journal LIMIT 10;

```

```{sql connection=dbs}

--SELECT COUNT(*) from journal;

SELECT * from journalData;
```



```{sql connection=dbs}
DROP TABLE journalData
```


```{r}
dbWriteTable(dbs, "articleData",newArticle.df )
```



```{sql connection=dbs}

SELECT distinct PMID from articleData
```


Remove year/ month/day?
, year,month,day
, artYear,artMonth,artDay
```{sql connection=dbs}
INSERT INTO Article (PMID , journalISSN, title, pagination,language)
SELECT  PMID, journalISSN, articleTitle, pagination,language
FROM articleData


```

```{sql connection=dbs}

SELECT * from Article 
```

```{sql connection=dbs}
DROP TABLE articleData
```



```{r}
dbWriteTable(dbs, "histData",newHistory.df , overwrite = TRUE)
```

History information for the 19 published articles, use year-month-date form this table for star schema
```{sql connection=dbs}

SELECT  DiSTINCT * FROM histData  WHERE pubStatus = "pubmed" 
```

```{sql connection=dbs}
INSERT INTO History (PMID , pubStatus, year, month,day)
SELECT  PMID , pubStatus, year, month,day
FROM histData


```

```{sql connection=dbs}

SELECT * from History
```



```{r}
dbWriteTable(dbs, "authorData",newAuthor.df, overwrite = TRUE)
```

```{sql connection=dbs}

SELECT* from authorData
```


```{sql connection=dbs}
INSERT INTO Author ( lastName, foreName, initials,affiliation)
SELECT   lastName, foreName, initials,affiliation
FROM authorData

```

```{sql connection=dbs}

SELECT distinct * from Author limit 5
```

Initials is not included in the keys for Authorship because it dosent impact the results. 84 unique first and last name pairs, and 84 first, last and initial pairs.
```{sql connection=dbs}
INSERT INTO Authorship ( PMID, lastName, foreName)
SELECT   PMID, lastName, foreName
FROM authorData


```


```{sql connection=dbs}

SELECT * from Authorship limit 5
```


```{sql connection=dbs}
DROP TABLE authorData
```


### Part 2
## Creae new and db Star schema



```{r}
dbPub <- dbConnect(RSQLite::SQLite(), "pubMedStar.db")
```



```{sql connection=dbPub}
--use to clear tables
DROP TABLE IF EXISTS dimAuthor;
```


```{sql connection=dbPub}
DROP TABLE IF EXISTS dimPubDate;
```

```{sql connection=dbPub}
DROP TABLE IF EXISTS dimJournal;
```

```{sql connection=dbPub}
DROP TABLE IF EXISTS dimHistory;
```

```{sql connection=dbPub}
DROP TABLE IF EXISTS articleFact;

```



## realize star schema tables

```{sql connection=dbPub}
CREATE TABLE IF NOT EXISTS dimAuthor(
  authorRef INTEGER NOT NULL, 
 -- PMID INTEGER NOT NULL,
  lastName TEXT NULL, 
  foreName TEXT NULL, 
  affiliation TEXT NULL, 
  PRIMARY KEY(authorRef) 
  );

```


#pubMedDate col
```{sql connection=dbPub}
CREATE TABLE IF NOT EXISTS dimPubDate(
  dateRef INTEGER,
  year INTEGER NULL,
  month INTEGER NULL,
  day INTEGER NULL,
  quarter INTEGER NULL,
  PRIMARY KEY (dateRef)
  );

```


```{sql connection=dbPub}

CREATE TABLE IF NOT EXISTS dimJournal(
  journalRef INTEGER NOT NULL,
  issn TEXT NOT NULL,
  volume TEXT NULL,
  issue TEXT NULL,
  PRIMARY KEY (journalId)
  );

```


may need to add pubStatus later
```{sql connection=dbPub}

CREATE TABLE IF NOT EXISTS dimHistory(
  historyRef INTEGER, 
  dateCreated INTEGER,
  PRIMARY KEY (historyRef)
  );

```


compound key - (pmid, authorRef) connect author to specific article
```{sql connection=dbPub}

CREATE TABLE IF NOT EXISTS articleFact(
  PMID INTEGER NOT NULL,
  authorRef INTEGER NOT NULL, 
  journalRef INTEGER NOT NULL,
  dateRef INTEGER NOT NULL,
  historyRef INTEGER NOT NULL,
  FOREIGN KEY (authorRef) REFERENCES dimAuthor(authorRef),
  FOREIGN KEY (journalRef) REFERENCES dimJournal(journalRef), 
  FOREIGN KEY (dateRef) REFERENCES dimPubDate(dateRef),
  FOREIGN KEY (historyRef) REFERENCES dimHistory(historyRef),
  PRIMARY KEY (PMID, authorRef)
);

```


```{r}
dbListTables(dbPub)
dbListTables(dbs)
```




```{sql connection=dbs}

SELECT * From Author;
```

Attach databases
https://www.sqlite.org/lang_attach.html 
https://www.tutorialspoint.com/sqlite/sqlite_attach_database.htm 
Insert info into star schema db from above nf db

```{sql connection=dbPub}
ATTACH DATABASE 'pubMedStar.db' AS s;
```


```{sql connection=dbPub}
ATTACH DATABASE 'pubMed.db' AS p;

INSERT INTO s.dimAuthor SELECT authorKey as authorRef, lastName, foreName, initials, affiliation FROM p.Author ;


```



## Using original table to get 
```{sql connection=dbPub}
UPDATE dimPubDate(dateRef, year, month, day, quarter)
SELECT History AS historyDimId,
 History.month || "-" || History.day || "-" || History.year AS date,
 History.month as historyMonth,
 History.day as historyDay,
  CASE
    WHEN History.month BETWEEN 1 AND 3 THEN 1
    WHEN History.month BETWEEN 4 AND 6 THEN 2
    WHEN History.month BETWEEN 7 AND 9 THEN 3
    WHEN History.month Between 10 AND 12 THEN 4
  END
  FROM History

```




```{r}

dbDisconnect(dbs)

```


### Part 3 use the OLAP star/snowflake schema to do some (simple) data mining




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

