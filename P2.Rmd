---
title: "P2"
output: html_document
---



Notes for the grader:
-the date in the history table where the PubStatus is 'pubmed' is assumed to be the publication data for this practicum because it is included in every node, is in integer form and is complete. This was verified as acceptable with the professor.





### Part 1 Load XML: Create a normalized relational OLTP database
```{r}
#pacman (package manager) installs and loads packages if not installed
pacman::p_load(pacman, RSQLite, XML, DBI, tidyverse, xml2)
#create db to set schema and load data to


fpath = "C:/Users/brive/OneDrive/Desktop/DatabaseSystems/"
dbfile = "pubMed.db" 

dbs <- dbConnect(RSQLite::SQLite(), paste0(fpath,dbfile))
```

```{r}
path <- "C:/Users/brive/OneDrive/Desktop/DatabaseSystems/"
xmlFile <- "pubmed_sampleV2.xml"

#xmlFile <- "pubmed_sample.xml"

fpn <- paste0(path,xmlFile)
xml_data <- xmlParse(file = fpn)
nodes <- getNodeSet(xml_data, "//PubmedArticle") 
r <- xmlRoot(xml_data)
# Get the name of the node to confirm
xmlName(r)

numPubMeds <- xmlSize(r)

```

## Part 1 Question 2

need to insert ER diagram !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

## Part 1 Question 2 and Question 3 (combined, not seperated by question)

data is collected from the XML here
```{r}

newJournal.df <- data.frame(ISSN = character(),#cant be numeric with a hyphen?
                          journalTitle = character(),
                          ISOabbrevation = character(),
                          volume = numeric(),
                          Issue = numeric(),
                          #pubYear = numeric(),
                          #pubMonth = character(),
                          stringsAsFactors = F)

colnames(newJournal.df) <- c("ISSN","journalTitle", 
                             "ISOabbrevation","Issue","volume")#,"pubYear","pubMonth")

r <- xmlRoot(xml_data)

for (m in 1:19)
{

  aJournalNode <- r[[m]][[1]][['Article']][['Journal']] #

  aJournal <- aJournalNode[[m]]
  ISSN <- xpathSApply(aJournalNode, "./ISSN", xmlValue)
  journalTitle <- xpathSApply(aJournalNode, "./Title", xmlValue)
  ISOabbrevation <- xpathSApply(aJournalNode, "./ISOAbbreviation", xmlValue)
  volume<-xpathSApply(aJournalNode, "./JournalIssue/Volume", xmlValue)
  Issue <-xpathSApply(aJournalNode, "./JournalIssue/Issue", xmlValue)
  
  #pubYear<-xpathSApply(aJournalNode, "./JournalIssue/PubDate/Year", xmlValue)
  #pubMonth <-xpathSApply(aJournalNode, "./JournalIssue/PubDate/Month", xmlValue)
    
    
  if (length(ISSN) == 0)
    ISSN <- ""
  if (length(journalTitle) == 0)
    journalTitle <- ""
  if (length(ISOabbrevation) == 0)
    ISOabbrevation <- ""
  #if (length(pubMonth) == 0)
  #  pubMonth <- ""

  newJournal.df[m,1] <- ISSN
  newJournal.df[m,2] <- journalTitle
  newJournal.df[m,3] <- ISOabbrevation
  newJournal.df[m,4] <- volume
  newJournal.df[m,5] <- Issue
  #newJournal.df[m,6] <- pubYear
  #newJournal.df[m,7] <- pubMonth
}
  
```
```{r}
#commented out so not seen in a knitted file
#newJournal.df
```


```{r}
newArticle.df <- data.frame(PMID = numeric(), #
                          journalISSN = character(),
                          articleTitle = character(),
                          pagination = character(),
                          #elocationID can have more then 1. need another table for that?
                          #same with abstract
                          #and author list- different table? what to use as a key?
                          language = character(),
                          #grant list?
                          #publication type tist?
                          artYear = numeric(),
                          artMonth = numeric(),
                          artDay = numeric(),
                          pubYear = numeric(),
                          pubMonth = character(),
                          stringsAsFactors = F)

colnames(newArticle.df) <- c("PMID","journalISSN", 
                             "articleTitle","pagination","language", 
                             "artYear", "artMonth", "artDay", 'pubYear', "pubMonth")#

r <- xmlRoot(xml_data)

for (m in 1:19)
{
  
  anArticleNode <- r[[m]][[1]][['Article']]#[['Journal']] #

  PMID <- xpathSApply(r[[m]][[1]], "./PMID", xmlValue)
  journalISSN <- xpathSApply(anArticleNode, "./Journal/ISSN", xmlValue)
  articleTitle <- xpathSApply(anArticleNode, "./ArticleTitle", xmlValue)
  pagination <- xpathSApply(anArticleNode, "./Pagination/MedlinePgn", xmlValue)
  language <- xpathSApply(anArticleNode, "./Language", xmlValue)
  
  artYear <- xpathSApply(anArticleNode, "./ArticleDate/Year", xmlValue)
  artMonth <- xpathSApply(anArticleNode, "./ArticleDate/Month", xmlValue)
  artDay <- xpathSApply(anArticleNode, "./ArticleDate/Day", xmlValue)
  
  pubYear <- xpathSApply(anArticleNode, "./Journal/JournalIssue/PubDate/Year", xmlValue)
  pubMonth <- xpathSApply(anArticleNode, "./Journal/JournalIssue/PubDate/Month", xmlValue)
  
  
  if (length(PMID) == 0)
    PMID <- ""
  if (length(journalISSN) == 0)
    journalISSN <- ""
  if (length(articleTitle) == 0)
    articleTitle <- ""
  if (length(pagination) == 0)
    pagination <- ""
  if (length(language) == 0)
    language <- ""
  if (length(artYear) == 0)
    artYear <- ""
  if (length(artMonth) == 0)
    artMonth <- ""
  if (length(artDay) == 0)
    artDay <- ""
  
  if (length(pubYear) == 0)
    pubYear <- ""
  if (length(pubMonth) == 0)
    pubMonth <- ""

  newArticle.df[m,1] <- PMID
  newArticle.df[m,2] <- journalISSN
  newArticle.df[m,3] <- articleTitle
  newArticle.df[m,4] <- pagination
  newArticle.df[m,5] <- language
  newArticle.df[m,6] <- artYear
  newArticle.df[m,7] <- artMonth
  newArticle.df[m,8] <- artDay
  newArticle.df[m,9] <- pubYear
  newArticle.df[m,10] <- pubMonth
}

```
```{r}
#commented out so not seen in a knitted file
#newArticle.df
```

```{r}

newAuthor.df <- data.frame(PMID = numeric(),
                          lastName = character(),
                          foreName = character(),
                          initials = character(),
                          affiliation = character(),
                          stringsAsFactors = F)

colnames(newAuthor.df) <- c("PMID","lastName","foreName", 
                             "initials","affiliation")

r <- xmlRoot(xml_data)
rowCount <- 1
for (m in 1:19)
{

  PMID <- xpathSApply(r[[m]][[1]], "./PMID", xmlValue)
  if (length(PMID) == 0)
    PMID <- ""
  
  anAuthorNodeList <- r[[m]][[1]][['Article']][['AuthorList']] 
  
  j<-xmlSize(anAuthorNodeList)
  
  
  for (k in 1:j){
    
    node <-anAuthorNodeList[[k]]
    lastName <- xpathSApply(node, "./LastName", xmlValue)
    foreName <- xpathSApply(node, "./ForeName", xmlValue)
    initials <- xpathSApply(node, "./Initials", xmlValue)
    affiliation <- xpathSApply(node, "./Affiliation", xmlValue)
    
    if (length(lastName) == 0)
      lastName <- ""
    if (length(foreName) == 0)
      foreName <- ""
    if (length(initials) == 0)
      initials <- ""
    if (length(affiliation) == 0)
      affiliation <- ""
    
    newAuthor.df[rowCount,1] <- PMID
    newAuthor.df[rowCount,2] <- lastName
    newAuthor.df[rowCount,3] <- foreName
    newAuthor.df[rowCount,4] <- initials
    newAuthor.df[rowCount,5] <- affiliation
    
    
    rowCount <- rowCount+1
  }

}
  
```
```{r}
#commented out so not seen in a knitted file
#newAuthor.df
```


```{r}

newHistory.df <- data.frame(PMID = numeric(),
                          pubStatus = character(),
                          year = numeric(),
                          month = numeric(),
                          day = numeric(),
                          #hour and minute not useful for analysis?
                          stringsAsFactors = F)

colnames(newHistory.df) <- c("PMID","pubStatus","year", 
                             "month","day")

r <- xmlRoot(xml_data)
rowCount <- 1
for (m in 1:19)
{

  PMID <- xpathSApply(r[[m]][[1]], "./PMID", xmlValue)
  if (length(PMID) == 0)
    PMID <- ""
  
  aHistoryList <- r[[m]][['PubmedData']][['History']]
  
  j<-xmlSize(aHistoryList)
  
  
  for (k in 1:j){
    
    node <-aHistoryList[[k]]
    
    pubStatus <- xmlGetAttr(node,'PubStatus')

    year <- xpathSApply(node, "./Year", xmlValue)
    month <- xpathSApply(node, "./Month", xmlValue)
    day <- xpathSApply(node, "./Day", xmlValue)
    

    if (length(pubStatus) == 0)
      pubStatus <- ""
    if (length(year) == 0)
      year <- ""
    if (length(month) == 0)
      month <- ""
    if (length(day) == 0)
      day <- ""
    
    newHistory.df[rowCount,1] <- PMID
    newHistory.df[rowCount,2] <- pubStatus
    newHistory.df[rowCount,3] <- year
    newHistory.df[rowCount,4] <- month
    newHistory.df[rowCount,5] <- day
    
    
    rowCount <- rowCount+1
  }

}
  
```
```{r}
#commented out so not seen in a knitted file
#newHistory.df
```



Tables are created here

```{sql connection=dbs}
DROP TABLE IF EXISTS Journal
```
```{sql connection=dbs}
DROP TABLE IF EXISTS Article
```
```{sql connection=dbs}
DROP TABLE IF EXISTS Authorship
```
```{sql connection=dbs}
DROP TABLE IF EXISTS Author
```
```{sql connection=dbs}
DROP TABLE IF EXISTS History
```

not sure if issn can be a numeric if there is a dash. Also not 100% sure a varchar can be a primary key, even if it is unique (journal table.)

uncertain if the foreign key goes here or in article. only in one of them. double check 
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS Journal (
  ISSN varchar(255) primary key,
  title varchar(255),
  ISOabbrevation varchar(255)

  );
```

articleKey INTEGER primary key AUTOINCREMENT,

  year int(255),
  month int(255),
  day int(255),
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS Article (
  
  PMID int(255) NOT NULL,
  journalISSN varchar(255),
  title varchar(255),
  pagination varchar(255),
  language varchar(255),


  FOREIGN KEY (journalISSN ) REFERENCES Journal(ISSN)
  );
```

  histKey INTEGER primary key AUTOINCREMENT,
  
  use compound key instead?
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS History (

  PMID int(255),
  pubStatus varchar(255),
  year int(255),
  month int(255),
  day int(255),
  PRIMARY  KEY (PMID, pubStatus),
  FOREIGN KEY (PMID) REFERENCES Article(PMID)
  );
```

adding in this lookup table
might need compound primary key?
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS Authorship (
  lookupKey INTEGER primary key AUTOINCREMENT,
  PMID int(255),
  lastName varchar(255),
  foreName varchar(255),
  FOREIGN KEY (PMID) REFERENCES Article(PMID),
  FOREIGN KEY (lastName, foreName) REFERENCES Author(lastName, foreName)
  );
```

  PMID int(255),
  
  ,
  FOREIGN KEY (PMID) REFERENCES Article(PMID)
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS Author (
  authorKey INTEGER primary key AUTOINCREMENT,

  lastName varchar(255),
  foreName varchar(255),
  initials varchar(255),
  affiliation varchar(255)
  );
```


Inserting data into the tables. Will likely need to be adjusted 

```{r}
dbWriteTable(dbs, "journalData",newJournal.df )
```
```{sql connection=dbs}

SELECT distinct 
ISSN,journalTitle,ISOabbrevation from journalData 
```

```{sql connection=dbs}
INSERT INTO Journal (ISSN , title,ISOabbrevation)
SELECT  distinct ISSN, journalTitle, ISOabbrevation
FROM journalData


```
```{sql connection=dbs}

SELECT ISOabbrevation from Journal limit 5
```
```{sql connection=dbs}
DROP TABLE journalData
```


```{r}
dbWriteTable(dbs, "articleData",newArticle.df )
```
```{sql connection=dbs}

SELECT distinct PMID from articleData
```


Remove year/ month/day?
, year,month,day
, artYear,artMonth,artDay
```{sql connection=dbs}
INSERT INTO Article (PMID , journalISSN, title, pagination,language)
SELECT  PMID, journalISSN, articleTitle, pagination,language
FROM articleData


```
```{sql connection=dbs}

SELECT * from Article limit 5
```
```{sql connection=dbs}
DROP TABLE articleData
```



```{r}
dbWriteTable(dbs, "histData",newHistory.df )
```
```{sql connection=dbs}

SELECT  distinct * from histData  where pubStatus = "pubmed" 
```

```{sql connection=dbs}
INSERT INTO History (PMID , pubStatus, year, month,day)
SELECT  PMID , pubStatus, year, month,day
FROM histData


```
```{sql connection=dbs}

SELECT * from History limit 5
```
```{sql connection=dbs}
DROP TABLE histData
```


```{r}
dbWriteTable(dbs, "authorData",newAuthor.df )
```
```{sql connection=dbs}

SELECT  * from authorData
```

PMID ,
PMID ,
```{sql connection=dbs}
INSERT INTO Author ( lastName, foreName, initials,affiliation)
SELECT   lastName, foreName, initials,affiliation
FROM authorData


```
```{sql connection=dbs}

SELECT distinct * from Author limit 5
```

Initials is not included in the keys for Authorship because it dosent impact the results. 84 unique first and last name pairs, and 84 first, last and initial pairs.
```{sql connection=dbs}
INSERT INTO Authorship ( PMID, lastName, foreName)
SELECT   PMID, lastName, foreName
FROM authorData


```
```{sql connection=dbs}

SELECT * from Authorship limit 5
```


```{sql connection=dbs}
DROP TABLE authorData
```



### Part 2



## Part 2 Question 1
need image of ERD

need to create the tables and populate the information.
syntax for this does not match the example because it was not for SQLite. just making tables with connections.

```{sql connection=dbs}
DROP TABLE IF EXISTS articleFact
```

refrence keys are all PMID or ISSN? is this allowed?
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS articleFact (
  PMID int(255) primary key,
  authorRefrence int(255),
  journalRefrence varchar(255),
  dateRefrence int(255),
  FOREIGN KEY (authorRefrence) REFERENCES authorDimenion(authorRefrence),
  FOREIGN KEY (journalRefrence) REFERENCES journalDimenion(dateRefrence),
  FOREIGN KEY (dateRefrence) REFERENCES authorDimenion(dateRefrence)
  );
```

quarter will just be 1-4
```{sql connection=dbs}
DROP TABLE IF EXISTS dateDimension
```
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS dateDimension(
  dateRefrence int(255) primary key,
  year int(255),
  month int(255),
  day int(255),
  quarter int(255)

  );
```

```{sql connection=dbs}
DROP TABLE IF EXISTS authorDimension
```
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS authorDimension(
  authorRefrence int(255) primary key,
  lastName varchar(255),
  foreName varchar(255)

  );
```

```{sql connection=dbs}
DROP TABLE IF EXISTS journalDimension
```
```{sql connection=dbs}
CREATE TABLE IF NOT EXISTS journalDimension(
  journalRefrence varchar(255) primary key
  );
```



not yet populated, should be fairly simple

## Part 2 Question 2

Note: to populate star schema, do computations in R and then insert that data into the tables.
insert, not dbwritetable. so make the tables and say insert where key == something? all based on article key? still kinda fuzzy on this. 
compute all facts in the data frames before uploading the data into any tables? easier to keep track of? maybe adjust the R dataframes down here, and populate the star schema from the frames with the new numerical answer


need image of ERD 

within the schema from above, which I think means a striped down version? either that or it means that any information included needs to be included in the above schema, but doesnt need all of it? 
or updated to include this fact table too? not very clear. 
### Part 3 use the OLAP star/snowflake schema to do some (simple) data mining

note: facts always result in a number? a fact is a recomputed aggregate number


## Part 3 Question 1
queries (plural) that explore publication seasonal pattern. need to be numerical results, and neesds to be more then just number of publications per season. need additional conditions maybe?


## Part 3 Question 2
Visualize the data from the previous step. More then one visualization maybe? unclear.
use ggplot
be sure to explain the findings.



do not do a predictive model. Could probably manage it but its harder and not worth any extra points. 















```{r}
dbDisconnect(dbs)
```
